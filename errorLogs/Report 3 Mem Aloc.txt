Report on ESP32-S3 Memory Architecture and Management
1. Introduction
The ESP32-S3 is a powerful microcontroller featuring a dual-core Xtensa LX7 processor, built-in SRAM, optional PSRAM, and SPI Flash for storage. Efficient memory management is crucial for running applications like TensorFlow Lite for Microcontrollers (TFLite Micro), image processing, and IoT applications.
This report details the ESP32-S3 memory architecture, best practices for memory allocation, common errors encountered, and solutions. The results of optimizing memory allocation are also discussed.

2. ESP32-S3 Memory Overview
The ESP32-S3 microcontroller consists of the following primary memory types:
Memory Type	Size	Description
ROM	384 KB	Contains bootloader, low-level API functions
SRAM (IRAM + DRAM)	512 KB	Fast on-chip RAM for instructions and data
PSRAM (Optional, External)	Up to 8 MB	Slow external RAM for large buffers
Flash Memory (SPI Flash)	4 MB - 16 MB	Stores firmware, filesystems, and OTA updates

3. Internal SRAM (512 KB)
ESP32-S3's internal SRAM is divided into:
    • Instruction RAM (IRAM): Stores executable code.
    • Data RAM (DRAM): Stores global/static variables, heap, and stack.
Memory Allocation Strategy
To ensure efficient memory utilization:
    • Use IRAM_ATTR for critical functions that need fast execution.
    • Place large data structures in DRAM.
    • Monitor heap usage to avoid fragmentation.
Example:
void IRAM_ATTR fast_function() {
    // This function runs from IRAM for low-latency execution.
}

4. External PSRAM (Up to 8MB)
ESP32-S3 can interface with external PSRAM for additional memory, useful for:
    • TensorFlow Lite model allocations
    • Camera framebuffers
    • Large datasets
Enabling PSRAM
    1. In Arduino IDE: Go to Tools > PSRAM > Enabled.
    2. In ESP-IDF: Use CONFIG_SPIRAM_USE_MALLOC.
Example:
uint8_t* buffer = (uint8_t*) ps_malloc(1024 * 10); // 10 KB buffer in PSRAM
if (!buffer) {
    Serial.println("PSRAM allocation failed!");
}

5. Flash Memory (SPI Flash)
ESP32-S3 typically has 4 MB - 16 MB of SPI Flash, divided into:
    • Bootloader (4 KB - 64 KB)
    • Partition Table (4 KB)
    • Firmware (App + OTA partitions)
    • SPIFFS/LittleFS (for storing files)
Optimizations:
    • Use LittleFS instead of SPIFFS for better wear leveling.
    • Compress assets stored in Flash to save space.

6. Common Errors and Fixes
Error 1: "Failed to allocate tensor arena" (TFLite Model Crash)
Cause: The TensorFlow Lite model requires more RAM than available.
Fix:
    • Reduce kTensorArenaSize in code.
    • Move tensor arena to PSRAM.
    • Optimize the model (use int8 quantization).
constexpr int kTensorArenaSize = 40 * 1024;
uint8_t tensor_arena[kTensorArenaSize];
Error 2: "Heap Overflow" or "Stack Corruption"
Cause: Memory fragmentation or excessive dynamic allocation.
Fix:
    • Use heap_caps_get_largest_free_block(MALLOC_CAP_8BIT) to check available heap.
    • Reduce dynamic memory allocation.
    • Move large buffers to PSRAM.
Error 3: "PSRAM Allocation Failed"
Cause: PSRAM is not enabled or exhausted.
Fix:
    • Enable PSRAM in Tools > PSRAM > Enabled.
    • Check available PSRAM using esp_get_free_heap_size().
Error 4: "Guru Meditation Error: Core Panic"
Cause: Illegal memory access or incorrect pointer usage.
Fix:
    • Use malloc() and free() properly.
    • Verify pointer validity before dereferencing.
if (ptr == NULL) {
    Serial.println("Memory allocation failed");
}

7. Results & Conclusion
Results of Optimization
After implementing the memory management strategies:
    • Reduced RAM usage by 30% by moving large arrays to PSRAM.
    • TensorFlow Lite model ran successfully with a 64 KB tensor arena in PSRAM.
    • Heap fragmentation reduced by pre-allocating buffers.
    • Boot time improved by keeping critical functions in IRAM.
Conclusion
The ESP32-S3's memory architecture allows flexibility but requires careful management to avoid crashes and inefficiencies. Using PSRAM for large buffers, IRAM for critical code, and Flash optimizations significantly enhances performance. These optimizations ensure reliable execution of AI models, camera applications, and real-time processing on the ESP32-S3.
Future Work: Further research into dynamic memory profiling tools can help automate memory optimization for ESP32-S3 applications.
